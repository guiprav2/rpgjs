<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="preflight.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
<link rel="stylesheet" href="rpg.css">
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-image: url("bg.png");
  }

  .rpg {
    outline: 4px solid #000000a0;
    border-radius: 4px;
    transform: scale(200%);
    image-rendering: crisp-edges;
  }
</style>
<body>
  <script type="module">
    import d from './dominant.js';
    import rpg from './rpg.js';

    class MainLevel {
      constructor({ game, roadblocks, map }) {
        Object.assign(this, { game, roadblocks, map });
      }

      waterFetched = false;
      waterbucket = (x, y, ...rest) => rpg.tileSprite(x, y, 0, 60, 0, ...rest);
      traphole = (...rest) => rpg.trap(4, 5, ...rest);

      render = () => rpg({ width: '320px', height: '256px' }, [
        rpg.viewport([
          rpg.tilemap('32px', '32px', 10, 8, 'ground.png', 'sonetto.png', this.roadblocks, [
            rpg.tiles(this.map.map(xs => rpg.tile(...xs))),
            rpg.sprites([
              rpg.hero(rpg.sprite(2, 3, '78px', '48px', 'siren.png')),
              rpg.sprite(3, 1, '111px', '62px', 'dracula.png', 0, {
                onAction: async () => {
                  if (!this.waterFetched) { alert('go fetch water') }
                  else { this.waterFetched = false; alert('thanks!') }
                  await new Promise(res => setTimeout(res, 1000));
                },
              }),
              this.waterbucket(7, 3, {
                onAction: async () => {
                  this.waterFetched = true; alert('water fetched!');
                  await new Promise(res => setTimeout(res, 1000));
                },
              }),
              this.traphole({
                onFall: async () => {
                  await this.game.load(UndergroundLevel);
                },
              }),
            ]),
          ]),
        ]),
      ]);
    }

    class UndergroundLevel {
      constructor({ game, roadblocks, map }) {
        Object.assign(this, { game, roadblocks, map });
      }

      render = () => rpg({ width: '320px', height: '256px' }, [
        rpg.viewport([
          rpg.tilemap('32px', '32px', 10, 8, 'dungeon_ground.png', 'sonetto.png', this.roadblocks, [
            rpg.tiles(this.map.map(xs => rpg.tile(...xs))),
            rpg.sprites([
              rpg.hero(rpg.sprite(4, 5, '78px', '48px', 'siren.png')),
              rpg.sprite(3, 1, '111px', '62px', 'dracula.png', 0, {
                onAction: async () => {
                  alert(`gah, you can't fetch water anymore`);
                  await new Promise(res => setTimeout(res, 1000));
                },
              }),
            ]),
          ]),
        ]),
      ]);
    }

    let loaders = new Map();

    loaders.set(MainLevel, async () => {
      let [roadblocks, map] = await Promise.all([
        fetch('./sonetto_roadblocks.json').then(x => x.json()),
        fetch('./map_a.json').then(x => x.json()),
      ]);
      return { roadblocks, map };
    });

    loaders.set(UndergroundLevel, async () => {
      let [roadblocks, map] = await Promise.all([
        fetch('./sonetto_roadblocks.json').then(x => x.json()),
        fetch('./map_b.json').then(x => x.json()),
      ]);
      return { roadblocks, map };
    });

    class Game {
      constructor() {
        this.load(MainLevel, { game: this });
      }

      load = async Level => {
        let data = await loaders.get(Level)();
        this.portal = d.el(Level, { ...data, game: this });
        d.update();
      };

      render = () => d.portal(() => this.portal);
    }

    document.body.append(d.el(Game));
  </script>
</body>
